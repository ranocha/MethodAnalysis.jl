<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MethodAnalysis.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MethodAnalysis.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Demonstrations"><span>Demonstrations</span></a></li><li><a class="tocitem" href="#API-reference"><span>API reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/timholy/MethodAnalysis.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MethodAnalysis.jl"><a class="docs-heading-anchor" href="#MethodAnalysis.jl">MethodAnalysis.jl</a><a id="MethodAnalysis.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MethodAnalysis.jl" title="Permalink"></a></h1><p>This package facilitates introspection of Julia&#39;s internals, with a particular focus on its MethodInstances and their backedges.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Julia&#39;s internals are not subject to the same interface compatibility guarantee that the rest of the language enjoys.</p></div></div><h2 id="Demonstrations"><a class="docs-heading-anchor" href="#Demonstrations">Demonstrations</a><a id="Demonstrations-1"></a><a class="docs-heading-anchor-permalink" href="#Demonstrations" title="Permalink"></a></h2><p>A few demonstrations will give you a taste of what can be done with this package.</p><h3 id="Collecting-all-submodules-of-Base"><a class="docs-heading-anchor" href="#Collecting-all-submodules-of-Base">Collecting all submodules of Base</a><a id="Collecting-all-submodules-of-Base-1"></a><a class="docs-heading-anchor-permalink" href="#Collecting-all-submodules-of-Base" title="Permalink"></a></h3><pre><code class="language-julia-repl">julia&gt; using MethodAnalysis

julia&gt; mods = Module[];

julia&gt; visit(Base) do obj
           if isa(obj, Module)
               push!(mods, obj)
               return true     # descend into submodules
           end
           false   # but don&#39;t descend into anything else (MethodTables, etc.)
       end

julia&gt; Base.FastMath ∈ mods
true</code></pre><h3 id="Collecting-all-Methods-in-Core.Compiler"><a class="docs-heading-anchor" href="#Collecting-all-Methods-in-Core.Compiler">Collecting all Methods in Core.Compiler</a><a id="Collecting-all-Methods-in-Core.Compiler-1"></a><a class="docs-heading-anchor-permalink" href="#Collecting-all-Methods-in-Core.Compiler" title="Permalink"></a></h3><p><code>visit</code> also descends into functions, methods, and MethodInstances:</p><pre><code class="language-julia-repl">julia&gt; meths = []
Any[]

julia&gt; visit(Core.Compiler) do item
           isa(item, Method) &amp;&amp; push!(meths, item)
           true   # walk through everything
       end

julia&gt; first(methods(Core.Compiler.typeinf_ext)) ∈ meths
true</code></pre><h3 id="Getting-a-MethodInstance-for-a-particular-set-of-types"><a class="docs-heading-anchor" href="#Getting-a-MethodInstance-for-a-particular-set-of-types">Getting a MethodInstance for a particular set of types</a><a id="Getting-a-MethodInstance-for-a-particular-set-of-types-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-a-MethodInstance-for-a-particular-set-of-types" title="Permalink"></a></h3><pre><code class="language-julia-repl">julia&gt; foo(::AbstractVector) = 1
foo (generic function with 1 method)

julia&gt; methodinstance(foo, (Vector{Int},))   # we haven&#39;t called it yet, so it&#39;s not compiled


julia&gt; foo([1,2])
1

julia&gt; methodinstance(foo, (Vector{Int},))
MethodInstance for foo(::Vector{Int64})</code></pre><h3 id="Collecting-a-subset-of-MethodInstances-for-a-particular-function"><a class="docs-heading-anchor" href="#Collecting-a-subset-of-MethodInstances-for-a-particular-function">Collecting a subset of MethodInstances for a particular function</a><a id="Collecting-a-subset-of-MethodInstances-for-a-particular-function-1"></a><a class="docs-heading-anchor-permalink" href="#Collecting-a-subset-of-MethodInstances-for-a-particular-function" title="Permalink"></a></h3><p>Let&#39;s collect all single-argument compiled instances of <code>findfirst</code>:</p><pre><code class="language-julia-repl">julia&gt; mis = Core.MethodInstance[];

julia&gt; visit(findfirst) do item
           isa(item, Core.MethodInstance) &amp;&amp; length(Base.unwrap_unionall(item.specTypes).parameters) == 2 &amp;&amp; push!(mis, item)
           true
       end

julia&gt; mis
1-element Vector{Core.MethodInstance}:
 MethodInstance for findfirst(::BitVector)</code></pre><p>We checked that the length was 2, rather than 1, because the first parameter is the function type itself:</p><pre><code class="language-julia-repl">julia&gt; mis[1].specTypes
Tuple{typeof(findfirst), BitVector}</code></pre><p>There&#39;s also a convenience shortcut:</p><pre><code class="language-julia">julia&gt; mis = methodinstances(findfirst)</code></pre><h3 id="Getting-the-backedges-for-a-function"><a class="docs-heading-anchor" href="#Getting-the-backedges-for-a-function">Getting the backedges for a function</a><a id="Getting-the-backedges-for-a-function-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-the-backedges-for-a-function" title="Permalink"></a></h3><p>Let&#39;s see all the compiled instances of <code>Base.setdiff</code> and their immediate callers:</p><pre><code class="language-julia-repl">julia&gt; direct_backedges(setdiff)
6-element Vector{Any}:
     MethodInstance for setdiff(::Base.KeySet{Any, Dict{Any, Any}}, ::Base.KeySet{Any, Dict{Any, Any}}) =&gt; MethodInstance for keymap_merge(::Dict{Char, Any}, ::Dict{Any, Any})
     MethodInstance for setdiff(::Base.KeySet{Any, Dict{Any, Any}}, ::Base.KeySet{Any, Dict{Any, Any}}) =&gt; MethodInstance for keymap_merge(::Dict{Char, Any}, ::Union{Dict{Any, Any}, Dict{Char, Any}})
   MethodInstance for setdiff(::Base.KeySet{Char, Dict{Char, Any}}, ::Base.KeySet{Any, Dict{Any, Any}}) =&gt; MethodInstance for keymap_merge(::Dict{Char, Any}, ::Union{Dict{Any, Any}, Dict{Char, Any}})
   MethodInstance for setdiff(::Base.KeySet{Any, Dict{Any, Any}}, ::Base.KeySet{Char, Dict{Char, Any}}) =&gt; MethodInstance for keymap_merge(::Dict{Char, Any}, ::Union{Dict{Any, Any}, Dict{Char, Any}})
 MethodInstance for setdiff(::Base.KeySet{Char, Dict{Char, Any}}, ::Base.KeySet{Char, Dict{Char, Any}}) =&gt; MethodInstance for keymap_merge(::Dict{Char, Any}, ::Union{Dict{Any, Any}, Dict{Char, Any}})
                                   MethodInstance for setdiff(::Vector{Base.UUID}, ::Vector{Base.UUID}) =&gt; MethodInstance for deps_graph(::Pkg.Types.Context, ::Dict{Base.UUID, String}, ::Dict{Base.UUID, Pkg.Types.VersionSpec}, ::Dict{Base.UUID, Pkg.Resolve.Fixed})</code></pre><h3 id="Printing-backedges-as-a-tree"><a class="docs-heading-anchor" href="#Printing-backedges-as-a-tree">Printing backedges as a tree</a><a id="Printing-backedges-as-a-tree-1"></a><a class="docs-heading-anchor-permalink" href="#Printing-backedges-as-a-tree" title="Permalink"></a></h3><p>MethodAnalysis uses <a href="https://github.com/JuliaCollections/AbstractTrees.jl">AbstractTrees</a> to display the complete set of backedges:</p><pre><code class="language-julia-repl">julia&gt; mi = methodinstance(findfirst, (BitVector,))
MethodInstance for findfirst(::BitVector)

julia&gt; MethodAnalysis.print_tree(mi)
MethodInstance for findfirst(::BitVector)
├─ MethodInstance for prune_graph!(::Graph)
│  └─ MethodInstance for var&quot;#simplify_graph!#111&quot;(::Bool, ::typeof(simplify_graph!), ::Graph, ::Set{Int64})
│     └─ MethodInstance for simplify_graph!(::Graph, ::Set{Int64})
│        └─ MethodInstance for simplify_graph!(::Graph)
│           ├─ MethodInstance for trigger_failure!(::Graph, ::Vector{Int64}, ::Tuple{Int64, Int64})
│           │  ⋮
│           │
│           └─ MethodInstance for resolve_versions!(::Context, ::Vector{PackageSpec})
│              ⋮
│
└─ MethodInstance for update_solution!(::SolutionTrace, ::Graph)
   └─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)
      ├─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)
      │  ├─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)
      │  │  ├─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)
      │  │  │  ⋮
      │  │  │
      │  │  └─ MethodInstance for maxsum(::Graph)
      │  │     ⋮
      │  │
      │  └─ MethodInstance for maxsum(::Graph)
      │     └─ MethodInstance for resolve(::Graph)
      │        ⋮
      │
      └─ MethodInstance for maxsum(::Graph)
         └─ MethodInstance for resolve(::Graph)
            ├─ MethodInstance for trigger_failure!(::Graph, ::Vector{Int64}, ::Tuple{Int64, Int64})
            │  ⋮
            │
            └─ MethodInstance for resolve_versions!(::Context, ::Vector{PackageSpec})
               ⋮</code></pre><h3 id="Finding-the-callers-of-a-method"><a class="docs-heading-anchor" href="#Finding-the-callers-of-a-method">Finding the callers of a method</a><a id="Finding-the-callers-of-a-method-1"></a><a class="docs-heading-anchor-permalink" href="#Finding-the-callers-of-a-method" title="Permalink"></a></h3><p>To find already-compiled callers of <code>sum(::Vector{Int})</code></p><pre><code class="language-julia"># Collect all MethodInstances
mis = methodinstances();
# Create a function that returns `true` for the correct set of argument types
argmatch(argtyps) = length(argtyps) == 1 &amp;&amp; argtyps[1] === Vector{Int}
# Find the calls that match
findcallers(sum, argmatch, mis)</code></pre><p>There are more options, see the help for <code>findcallers</code>.</p><h2 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h2><h3 id="visit"><a class="docs-heading-anchor" href="#visit">visit</a><a id="visit-1"></a><a class="docs-heading-anchor-permalink" href="#visit" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.visit" href="#MethodAnalysis.visit"><code>MethodAnalysis.visit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visit(operation, obj; print::Bool=false)</code></pre><p>Scan <code>obj</code> and all of its &quot;sub-objects&quot; (e.g., functions if <code>obj::Module</code>, methods if <code>obj::Function</code>, etc.) recursively. <code>operation(x)</code> should return <code>true</code> if <code>visit</code> should descend into &quot;sub-objects&quot; of <code>x</code>.</p><p>If <code>print</code> is <code>true</code>, each visited object is printed to standard output.</p><p><strong>Example</strong></p><p>To collect all MethodInstances of a function,</p><pre><code class="language-julia-repl">julia&gt; mis = Core.MethodInstance[];

julia&gt; visit(findfirst) do x
           if isa(x, Core.MethodInstance)
               push!(mis, x)
               return false
           end
           true
       end

julia&gt; length(mis)
34</code></pre><p>The exact number of MethodInstances will depend on what code you&#39;ve run in your Julia session.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/418be8bacacf85ba6f5f50997df0a46813f9b3e0/src/visit.jl#LL1-L31">source</a></section><section><div><pre><code class="language-none">visit(operation; print::Bool=false)</code></pre><p>Scan all loaded modules with <code>operation</code>. See <a href="#MethodAnalysis.visit"><code>visit(operation, obj)</code></a> for further detail.</p><p><strong>Example</strong></p><p>Collect all loaded modules, even if they are internal.</p><pre><code class="language-julia-repl">julia&gt; mods = Module[];

julia&gt; visit() do x
           if isa(x, Module)
               push!(mods, x)
               return true
           end
           false
       end</code></pre><p>julia&gt; mods 113-element Array{Module,1}:  Random  Random.DSFMT [...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/418be8bacacf85ba6f5f50997df0a46813f9b3e0/src/visit.jl#LL35-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.visit_backedges" href="#MethodAnalysis.visit_backedges"><code>MethodAnalysis.visit_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visit_backedges(operation, obj)</code></pre><p>Visit the backedges of <code>obj</code> and apply <code>operation</code> to each. <code>operation</code> may need to be able to handle two call forms, <code>operation(mi)</code> and <code>operation(sig=&gt;mi)</code>, where <code>mi</code> is a <code>MethodInstance</code> and <code>sig</code> is a <code>Tuple</code>-type. The latter arises from <code>MethodTable</code> backedges and can be ignored if <code>obj</code> does not contain <code>MethodTable</code>s.</p><p><code>operation(edge)</code> should return <code>true</code> if the backedges of <code>edge</code> should in turn be visited, <code>false</code> otherwise. However, no <code>MethodInstance</code> will be visited more than once.</p><p>The set of visited objects includes <code>obj</code> itself. For example, <code>visit_backedges(operation, f::Function)</code> will visit all methods of <code>f</code>, and this in turn will visit all MethodInstances of these methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/418be8bacacf85ba6f5f50997df0a46813f9b3e0/src/visit.jl#LL184-L200">source</a></section></article><h3 id="backedges"><a class="docs-heading-anchor" href="#backedges">backedges</a><a id="backedges-1"></a><a class="docs-heading-anchor-permalink" href="#backedges" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.all_backedges" href="#MethodAnalysis.all_backedges"><code>MethodAnalysis.all_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_backedges(mi::MethodInstance)</code></pre><p>Return a list of all backedges (direct and indirect) of <code>mi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/418be8bacacf85ba6f5f50997df0a46813f9b3e0/src/backedges.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.direct_backedges" href="#MethodAnalysis.direct_backedges"><code>MethodAnalysis.direct_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">direct_backedges(f::Function; skip=true)</code></pre><p>Collect all backedges for a function <code>f</code> as pairs <code>instance=&gt;caller</code> or <code>sig=&gt;caller</code> pairs. The latter occur for MethodTable backedges. If <code>skip</code> is <code>true</code>, any <code>caller</code> listed in a MethodTable backedge is omitted from the instance backedges. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/418be8bacacf85ba6f5f50997df0a46813f9b3e0/src/backedges.jl#LL50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.terminal_backedges" href="#MethodAnalysis.terminal_backedges"><code>MethodAnalysis.terminal_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">terminal_backedges(mi::MethodInstance)</code></pre><p>Obtain the &quot;ultimate callers&quot; of <code>mi</code>, i.e., the reason(s) <code>mi</code> was compiled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/418be8bacacf85ba6f5f50997df0a46813f9b3e0/src/backedges.jl#LL33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.with_all_backedges" href="#MethodAnalysis.with_all_backedges"><code>MethodAnalysis.with_all_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">with_all_backedges(itr)</code></pre><p>Return all MethodInstances detected when iterating through items in <code>itr</code> and any their backedges. The result includes both MethodTable and MethodInstance backedges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/418be8bacacf85ba6f5f50997df0a46813f9b3e0/src/backedges.jl#LL13-L18">source</a></section></article><h3 id="utilities"><a class="docs-heading-anchor" href="#utilities">utilities</a><a id="utilities-1"></a><a class="docs-heading-anchor-permalink" href="#utilities" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.methodinstance" href="#MethodAnalysis.methodinstance"><code>MethodAnalysis.methodinstance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mi = methodinstance(f, types)
mi = methodinstance(tt::Type{&lt;:Tuple})</code></pre><p>Return the <code>MethodInstance</code> <code>mi</code> for function <code>f</code> and the given <code>types</code>, or for the complete signature <code>tt</code>. If no version compiled for these types exists, returns <code>nothing</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; f(x, y::String) = 2x; f(x, y::Number) = x + y;

julia&gt; f(1, &quot;hi&quot;); f(1, 1.0);

julia&gt; methodinstance(f, (Int, String))
MethodInstance for f(::Int64, ::String)

julia&gt; methodinstance(Tuple{typeof(f), Int, String})
MethodInstance for f(::Int64, ::String)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/418be8bacacf85ba6f5f50997df0a46813f9b3e0/src/MethodAnalysis.jl#LL68-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.methodinstances" href="#MethodAnalysis.methodinstances"><code>MethodAnalysis.methodinstances</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">methodinstances()
methodinstances(mod::Module)
methodinstances(f)</code></pre><p>Collect all <code>MethodInstance</code>s, optionally restricting them to a particular module, function, method, or methodlist.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/418be8bacacf85ba6f5f50997df0a46813f9b3e0/src/MethodAnalysis.jl#LL112-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.call_type" href="#MethodAnalysis.call_type"><code>MethodAnalysis.call_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">call_type(tt)</code></pre><p>Split a signature type like <code>Tuple{typeof(f),ArgTypes...}</code> back out to <code>(f, Tuple{ArgTypes...})</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/418be8bacacf85ba6f5f50997df0a46813f9b3e0/src/MethodAnalysis.jl#LL19-L23">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>findcallers</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.worlds" href="#MethodAnalysis.worlds"><code>MethodAnalysis.worlds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minmaxs = worlds(mi::MethodInstance)</code></pre><p>Collect the (min,max) world-age pairs for all CodeInstances associated with <code>mi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/418be8bacacf85ba6f5f50997df0a46813f9b3e0/src/MethodAnalysis.jl#LL31-L35">source</a></section></article><h3 id="types"><a class="docs-heading-anchor" href="#types">types</a><a id="types-1"></a><a class="docs-heading-anchor-permalink" href="#types" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>MethodAnalysis.CallMatch</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 12 December 2020 12:19">Saturday 12 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
