<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MethodAnalysis.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MethodAnalysis.jl</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Demonstrations-1"><span>Demonstrations</span></a></li><li><a class="tocitem" href="#API-reference-1"><span>API reference</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/timholy/MethodAnalysis.jl/blob/master/docs/src/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MethodAnalysis.jl-1"><a class="docs-heading-anchor" href="#MethodAnalysis.jl-1">MethodAnalysis.jl</a><a class="docs-heading-anchor-permalink" href="#MethodAnalysis.jl-1" title="Permalink"></a></h1><p>This package facilitates introspection of Julia&#39;s internals, with a particular focus on its MethodInstances and their backedges.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Julia&#39;s internals are not subject to the same interface compatibility guarantee that the rest of the language enjoys.</p></div></div><h2 id="Demonstrations-1"><a class="docs-heading-anchor" href="#Demonstrations-1">Demonstrations</a><a class="docs-heading-anchor-permalink" href="#Demonstrations-1" title="Permalink"></a></h2><p>A few demonstrations will give you a taste of what can be done with this package.</p><h3 id="Collecting-all-submodules-of-Base-1"><a class="docs-heading-anchor" href="#Collecting-all-submodules-of-Base-1">Collecting all submodules of Base</a><a class="docs-heading-anchor-permalink" href="#Collecting-all-submodules-of-Base-1" title="Permalink"></a></h3><pre><code class="language-julia-repl">julia&gt; using MethodAnalysis

julia&gt; mods = Module[];

julia&gt; visit(Base) do obj
           if isa(obj, Module)
               push!(mods, obj)
               return true     # descend into submodules
           end
           false   # but don&#39;t descend into anything else (MethodTables, etc.)
       end

julia&gt; Base.FastMath ∈ mods
true</code></pre><h3 id="Collecting-all-Methods-in-Core.Compiler-1"><a class="docs-heading-anchor" href="#Collecting-all-Methods-in-Core.Compiler-1">Collecting all Methods in Core.Compiler</a><a class="docs-heading-anchor-permalink" href="#Collecting-all-Methods-in-Core.Compiler-1" title="Permalink"></a></h3><p><code>visit</code> also descends into functions, methods, and MethodInstances:</p><pre><code class="language-julia-repl">julia&gt; meths = []
Any[]

julia&gt; visit(Core.Compiler) do item
           isa(item, Method) &amp;&amp; push!(meths, item)
           true   # walk through everything
       end

julia&gt; first(methods(Core.Compiler.typeinf_ext)) ∈ meths
true</code></pre><h3 id="Getting-a-MethodInstance-for-a-particular-set-of-types-1"><a class="docs-heading-anchor" href="#Getting-a-MethodInstance-for-a-particular-set-of-types-1">Getting a MethodInstance for a particular set of types</a><a class="docs-heading-anchor-permalink" href="#Getting-a-MethodInstance-for-a-particular-set-of-types-1" title="Permalink"></a></h3><pre><code class="language-julia-repl">julia&gt; foo(::AbstractVector) = 1
foo (generic function with 1 method)

julia&gt; instance(foo, (Vector{Int},))   # we haven&#39;t called it yet, so it&#39;s not compiled

julia&gt; foo([1,2])
1

julia&gt; instance(foo, (Vector{Int},))
MethodInstance for foo(::Array{Int64,1})</code></pre><h3 id="Collecting-a-subset-of-MethodInstances-for-a-particular-function-1"><a class="docs-heading-anchor" href="#Collecting-a-subset-of-MethodInstances-for-a-particular-function-1">Collecting a subset of MethodInstances for a particular function</a><a class="docs-heading-anchor-permalink" href="#Collecting-a-subset-of-MethodInstances-for-a-particular-function-1" title="Permalink"></a></h3><p>Let&#39;s collect all single-argument compiled instances of <code>findfirst</code>:</p><pre><code class="language-julia-repl">julia&gt; mis = Core.MethodInstance[];

julia&gt; visit(findfirst) do item
           isa(item, Core.MethodInstance) &amp;&amp; length(Base.unwrap_unionall(item.specTypes).parameters) == 2 &amp;&amp; push!(mis, item)
           true
       end

julia&gt; mis
1-element Array{Core.MethodInstance,1}:
 MethodInstance for findfirst(::BitArray{1})</code></pre><p>We checked that the length was 2, rather than 1, because the first parameter is the function type itself:</p><pre><code class="language-julia-repl">julia&gt; mis[1].specTypes
Tuple{typeof(findfirst),BitArray{1}}</code></pre><h3 id="Getting-the-backedges-for-a-function-1"><a class="docs-heading-anchor" href="#Getting-the-backedges-for-a-function-1">Getting the backedges for a function</a><a class="docs-heading-anchor-permalink" href="#Getting-the-backedges-for-a-function-1" title="Permalink"></a></h3><p>Let&#39;s see all the compiled instances of <code>Base.setdiff</code> and their immediate callers:</p><pre><code class="language-julia-repl">julia&gt; direct_backedges(setdiff)
3-element Array{Any,1}:
 MethodInstance for setdiff(::Base.KeySet{Any,Dict{Any,Any}}, ::Base.KeySet{Any,Dict{Any,Any}}) =&gt; MethodInstance for keymap_merge(::Dict{Char,Any}, ::Dict{Any,Any})
 MethodInstance for setdiff(::Base.KeySet{Any,Dict{Any,Any}}, ::Base.KeySet{Any,Dict{Any,Any}}) =&gt; MethodInstance for keymap_merge(::Any, ::Dict{Any,Any})
                         MethodInstance for setdiff(::Array{Base.UUID,1}, ::Array{Base.UUID,1}) =&gt; MethodInstance for deps_graph(::Pkg.Types.Context, ::Dict{Base.UUID,String}, ::Dict{Base.UUID,Pkg.Types.VersionSpec}, ::Dict{Base.UUID,Pkg.Resolve.Fixed})</code></pre><h3 id="Printing-backedges-as-a-tree-1"><a class="docs-heading-anchor" href="#Printing-backedges-as-a-tree-1">Printing backedges as a tree</a><a class="docs-heading-anchor-permalink" href="#Printing-backedges-as-a-tree-1" title="Permalink"></a></h3><p>MethodAnalysis uses <a href="https://github.com/JuliaCollections/AbstractTrees.jl">AbstractTrees</a> to display the complete set of backedges:</p><pre><code class="language-julia-repl">julia&gt; mi = instance(findfirst, (BitVector,))
MethodInstance for findfirst(::BitArray{1})

julia&gt; MethodAnalysis.print_tree(mi)
MethodInstance for findfirst(::BitArray{1})
├─ MethodInstance for prune_graph!(::Graph)
│  └─ MethodInstance for #simplify_graph!#111(::Bool, ::typeof(simplify_graph!), ::Graph, ::Set{Int64})
│     └─ MethodInstance for simplify_graph!(::Graph, ::Set{Int64})
│        └─ MethodInstance for simplify_graph!(::Graph)
│           ├─ MethodInstance for trigger_failure!(::Graph, ::Array{Int64,1}, ::Tuple{Int64,Int64})
│           │  ⋮
│           │  
│           └─ MethodInstance for resolve_versions!(::Context, ::Array{PackageSpec,1})
│              ⋮
│              
└─ MethodInstance for update_solution!(::SolutionTrace, ::Graph)
   └─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)
      ├─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)
      │  ├─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)
      │  │  ├─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)
      │  │  │  ⋮
      │  │  │  
      │  │  └─ MethodInstance for maxsum(::Graph)
      │  │     ⋮
      │  │     
      │  └─ MethodInstance for maxsum(::Graph)
      │     └─ MethodInstance for resolve(::Graph)
      │        ⋮
      │        
      └─ MethodInstance for maxsum(::Graph)
         └─ MethodInstance for resolve(::Graph)
            ├─ MethodInstance for trigger_failure!(::Graph, ::Array{Int64,1}, ::Tuple{Int64,Int64})
            │  ⋮
            │  
            └─ MethodInstance for resolve_versions!(::Context, ::Array{PackageSpec,1})
               ⋮</code></pre><h2 id="API-reference-1"><a class="docs-heading-anchor" href="#API-reference-1">API reference</a><a class="docs-heading-anchor-permalink" href="#API-reference-1" title="Permalink"></a></h2><h3 id="visit-1"><a class="docs-heading-anchor" href="#visit-1">visit</a><a class="docs-heading-anchor-permalink" href="#visit-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.visit" href="#MethodAnalysis.visit"><code>MethodAnalysis.visit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visit(operation, obj; print::Bool=false)</code></pre><p>Scan <code>obj</code> and all of its &quot;sub-objects&quot; (e.g., functions if <code>obj::Module</code>, methods if <code>obj::Function</code>, etc.) recursively. <code>operation(x)</code> should return <code>true</code> if <code>visit</code> should descend into &quot;sub-objects&quot; of <code>x</code>.</p><p>If <code>print</code> is <code>true</code>, each visited object is printed to standard output.</p><p><strong>Example</strong></p><p>To collect all MethodInstances of a function,</p><pre><code class="language-julia-repl">julia&gt; mis = Core.MethodInstance[];

julia&gt; visit(findfirst) do x
           if isa(x, Core.MethodInstance)
               push!(mis, x)
               return false
           end
           true
       end

julia&gt; length(mis)
34</code></pre><p>The exact number of MethodInstances will depend on what code you&#39;ve run in your Julia session.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/bd3cf2e3b99ac17f1c5750d86370192747a8320a/src/visit.jl#LL1-L31">source</a></section><section><div><pre><code class="language-none">visit(operation; print::Bool=false)</code></pre><p>Scan all loaded modules with <code>operation</code>. See <a href="#MethodAnalysis.visit"><code>visit(operation, obj)</code></a> for further detail.</p><p><strong>Example</strong></p><p>Collect all loaded modules, even if they are internal.</p><pre><code class="language-julia-repl">julia&gt; mods = Module[];

julia&gt; visit() do x
           if isa(x, Module)
               push!(mods, x)
               return true
           end
           false
       end</code></pre><p>julia&gt; mods 113-element Array{Module,1}:  Random  Random.DSFMT [...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/bd3cf2e3b99ac17f1c5750d86370192747a8320a/src/visit.jl#LL35-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.visit_backedges" href="#MethodAnalysis.visit_backedges"><code>MethodAnalysis.visit_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">visit_backedges(operation, obj)</code></pre><p>Visit the backedges of <code>obj</code> and apply <code>operation</code> to each. <code>operation</code> may need to be able to handle two call forms, <code>operation(mi)</code> and <code>operation(sig=&gt;mi)</code>, where <code>mi</code> is a <code>MethodInstance</code> and <code>sig</code> is a <code>Tuple</code>-type. The latter arises from <code>MethodTable</code> backedges and can be ignored if <code>obj</code> does not contain <code>MethodTable</code>s.</p><p><code>operation(edge)</code> should return <code>true</code> if the backedges of <code>edge</code> should in turn be visited, <code>false</code> otherwise. However, no <code>MethodInstance</code> will be visited more than once.</p><p>The set of visited objects includes <code>obj</code> itself. For example, <code>visit_backedges(operation, f::Function)</code> will visit all methods of <code>f</code>, and this in turn will visit all MethodInstances of these methods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/bd3cf2e3b99ac17f1c5750d86370192747a8320a/src/visit.jl#LL172-L188">source</a></section></article><h3 id="backedges-1"><a class="docs-heading-anchor" href="#backedges-1">backedges</a><a class="docs-heading-anchor-permalink" href="#backedges-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.all_backedges" href="#MethodAnalysis.all_backedges"><code>MethodAnalysis.all_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_backedges(mi::MethodInstance)</code></pre><p>Return a list of all backedges (direct and indirect) of <code>mi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/bd3cf2e3b99ac17f1c5750d86370192747a8320a/src/backedges.jl#LL1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.direct_backedges" href="#MethodAnalysis.direct_backedges"><code>MethodAnalysis.direct_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">direct_backedges(f::Function; skip=true)</code></pre><p>Collect all backedges for a function <code>f</code> as pairs <code>instance=&gt;caller</code> or <code>sig=&gt;caller</code> pairs. The latter occur for MethodTable backedges. If <code>skip</code> is <code>true</code>, any <code>caller</code> listed in a MethodTable backedge is omitted from the instance backedges. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/bd3cf2e3b99ac17f1c5750d86370192747a8320a/src/backedges.jl#LL50-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.terminal_backedges" href="#MethodAnalysis.terminal_backedges"><code>MethodAnalysis.terminal_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">terminal_backedges(mi::MethodInstance)</code></pre><p>Obtain the &quot;ultimate callers&quot; of <code>mi</code>, i.e., the reason(s) <code>mi</code> was compiled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/bd3cf2e3b99ac17f1c5750d86370192747a8320a/src/backedges.jl#LL33-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.with_all_backedges" href="#MethodAnalysis.with_all_backedges"><code>MethodAnalysis.with_all_backedges</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">with_all_backedges(itr)</code></pre><p>Return all MethodInstances detected when iterating through items in <code>itr</code> and any their backedges. The result includes both MethodTable and MethodInstance backedges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/bd3cf2e3b99ac17f1c5750d86370192747a8320a/src/backedges.jl#LL13-L18">source</a></section></article><h3 id="utilities-1"><a class="docs-heading-anchor" href="#utilities-1">utilities</a><a class="docs-heading-anchor-permalink" href="#utilities-1" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.instance" href="#MethodAnalysis.instance"><code>MethodAnalysis.instance</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mi = instance(f, types)</code></pre><p>Return the <code>MethodInstance</code> <code>mi</code> for function <code>f</code> and the given <code>types</code>. If no version compiled for these types exists, returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/bd3cf2e3b99ac17f1c5750d86370192747a8320a/src/MethodAnalysis.jl#LL66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.call_type" href="#MethodAnalysis.call_type"><code>MethodAnalysis.call_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">call_type(tt)</code></pre><p>Split a signature type like <code>Tuple{typeof(f),ArgTypes...}</code> back out to <code>(f, Tuple{ArgTypes...})</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/bd3cf2e3b99ac17f1c5750d86370192747a8320a/src/MethodAnalysis.jl#LL17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MethodAnalysis.worlds" href="#MethodAnalysis.worlds"><code>MethodAnalysis.worlds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minmaxs = worlds(mi::MethodInstance)</code></pre><p>Collect the (min,max) world-age pairs for all CodeInstances associated with <code>mi</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/timholy/MethodAnalysis.jl/blob/bd3cf2e3b99ac17f1c5750d86370192747a8320a/src/MethodAnalysis.jl#LL29-L33">source</a></section></article></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 16 May 2020 14:20">Saturday 16 May 2020</span>. Using Julia version 1.4.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
