var documenterSearchIndex = {"docs":
[{"location":"#MethodAnalysis.jl-1","page":"Home","title":"MethodAnalysis.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package facilitates introspection of Julia's internals, with a particular focus on its MethodInstances and their backedges.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"warning: Warning\nJulia's internals are not subject to the same stability guarantee that the rest of the language enjoys.","category":"page"},{"location":"#Demonstrations-1","page":"Home","title":"Demonstrations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A few demonstrations will give you a taste of what can be done with this package.","category":"page"},{"location":"#Collecting-all-submodules-of-Base-1","page":"Home","title":"Collecting all submodules of Base","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> using MethodAnalysis\n\njulia> mods = Module[];\n\njulia> visit(Base; print=false) do obj\n           if isa(obj, Module)\n               push!(mods, obj)\n           end\n       end\n\njulia> Base.FastMath ∈ mods\ntrue","category":"page"},{"location":"#Collecting-all-Methods-in-Core.Compiler-1","page":"Home","title":"Collecting all Methods in Core.Compiler","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"visit also descends into functions, methods, and MethodInstances:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> meths = []\nAny[]\n\njulia> visit(Core.Compiler) do item    # without print=false it will display the modules it visits\n           isa(item, Method) && push!(meths, item)\n       end\nModule Core.Compiler\nModule Core.Compiler.CoreDocs\nModule Core.Compiler.Iterators\nModule Core.Compiler.Order\nModule Core.Compiler.Sort\nModule Core.Compiler.Sort.Float\n\njulia> first(methods(Core.Compiler.typeinf_ext)) ∈ meths\ntrue","category":"page"},{"location":"#Getting-a-MethodInstance-for-a-particular-set-of-types-1","page":"Home","title":"Getting a MethodInstance for a particular set of types","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> foo(::AbstractVector) = 1\nfoo (generic function with 1 method)\n\njulia> instance(foo, (Vector{Int},))   # we haven't called it yet, so it's not compiled\n\njulia> foo([1,2])\n1\n\njulia> instance(foo, (Vector{Int},))\nMethodInstance for foo(::Array{Int64,1})","category":"page"},{"location":"#Collecting-a-subset-of-MethodInstances-for-a-particular-function-1","page":"Home","title":"Collecting a subset of MethodInstances for a particular function","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Let's collect all single-argument compiled instances of findfirst:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> mis = Core.MethodInstance[];\n\njulia> visit(findfirst) do item\n           isa(item, Core.MethodInstance) && length(Base.unwrap_unionall(item.specTypes).parameters) == 2 && push!(mis, item)\n       end\n\njulia> mis\n1-element Array{Core.MethodInstance,1}:\n MethodInstance for findfirst(::BitArray{1})","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We checked that the length was 2, rather than 1, because the first parameter is the function type itself:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> mis[1].specTypes\nTuple{typeof(findfirst),BitArray{1}}","category":"page"},{"location":"#Getting-the-backedges-for-a-function-1","page":"Home","title":"Getting the backedges for a function","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Let's see all the compiled instances of Base.setdiff and their immediate callers:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> direct_backedges(setdiff)\n3-element Array{Any,1}:\n MethodInstance for setdiff(::Base.KeySet{Any,Dict{Any,Any}}, ::Base.KeySet{Any,Dict{Any,Any}}) => MethodInstance for keymap_merge(::Dict{Char,Any}, ::Dict{Any,Any})\n MethodInstance for setdiff(::Base.KeySet{Any,Dict{Any,Any}}, ::Base.KeySet{Any,Dict{Any,Any}}) => MethodInstance for keymap_merge(::Any, ::Dict{Any,Any})\n                         MethodInstance for setdiff(::Array{Base.UUID,1}, ::Array{Base.UUID,1}) => MethodInstance for deps_graph(::Pkg.Types.Context, ::Dict{Base.UUID,String}, ::Dict{Base.UUID,Pkg.Types.VersionSpec}, ::Dict{Base.UUID,Pkg.Resolve.Fixed})","category":"page"},{"location":"#Printing-backedges-as-a-tree-1","page":"Home","title":"Printing backedges as a tree","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"MethodAnalysis uses AbstractTrees to display the complete set of backedges:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> mi = instance(findfirst, (BitVector,))\nMethodInstance for findfirst(::BitArray{1})\n\njulia> MethodAnalysis.print_tree(mi)\nMethodInstance for findfirst(::BitArray{1})\n├─ MethodInstance for prune_graph!(::Graph)\n│  └─ MethodInstance for #simplify_graph!#111(::Bool, ::typeof(simplify_graph!), ::Graph, ::Set{Int64})\n│     └─ MethodInstance for simplify_graph!(::Graph, ::Set{Int64})\n│        └─ MethodInstance for simplify_graph!(::Graph)\n│           ├─ MethodInstance for trigger_failure!(::Graph, ::Array{Int64,1}, ::Tuple{Int64,Int64})\n│           │  ⋮\n│           │  \n│           └─ MethodInstance for resolve_versions!(::Context, ::Array{PackageSpec,1})\n│              ⋮\n│              \n└─ MethodInstance for update_solution!(::SolutionTrace, ::Graph)\n   └─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)\n      ├─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)\n      │  ├─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)\n      │  │  ├─ MethodInstance for converge!(::Graph, ::Messages, ::SolutionTrace, ::NodePerm, ::MaxSumParams)\n      │  │  │  ⋮\n      │  │  │  \n      │  │  └─ MethodInstance for maxsum(::Graph)\n      │  │     ⋮\n      │  │     \n      │  └─ MethodInstance for maxsum(::Graph)\n      │     └─ MethodInstance for resolve(::Graph)\n      │        ⋮\n      │        \n      └─ MethodInstance for maxsum(::Graph)\n         └─ MethodInstance for resolve(::Graph)\n            ├─ MethodInstance for trigger_failure!(::Graph, ::Array{Int64,1}, ::Tuple{Int64,Int64})\n            │  ⋮\n            │  \n            └─ MethodInstance for resolve_versions!(::Context, ::Array{PackageSpec,1})\n               ⋮","category":"page"},{"location":"#API-reference-1","page":"Home","title":"API reference","text":"","category":"section"},{"location":"#visit-1","page":"Home","title":"visit","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"visit\nvisit_backedges","category":"page"},{"location":"#MethodAnalysis.visit","page":"Home","title":"MethodAnalysis.visit","text":"visit(operation)\n\nScan all loaded modules with operation. operation(x) should handle x::Module, x::Function, x::Method, x::MethodInstance. Any return value from operation will be discarded.\n\n\n\n\n\n","category":"function"},{"location":"#MethodAnalysis.visit_backedges","page":"Home","title":"MethodAnalysis.visit_backedges","text":"visit_backedges(operation, obj)\n\nVisit the backedges of obj and apply operation to each. operation may need to be able to handle two call forms, operation(mi) and operation(sig=>mi), where mi is a MethodInstance and sig is a Tuple-type. The latter arises from MethodTable backedges and can be ignored if obj does not contain MethodTables.\n\noperation(edge) should return true if the backedges of edge should in turn be visited, false otherwise.\n\nThe set of visited objects includes obj itself. For example, visit_backedges(operation, f::Function) will visit all methods of f, and this in turn will visit all MethodInstances of these methods.\n\n\n\n\n\n","category":"function"},{"location":"#backedges-1","page":"Home","title":"backedges","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"all_backedges\ndirect_backedges\nterminal_backedges\nwith_all_backedges","category":"page"},{"location":"#MethodAnalysis.all_backedges","page":"Home","title":"MethodAnalysis.all_backedges","text":"all_backedges(mi::MethodInstance)\n\nReturn a list of all backedges (direct and indirect) of mi.\n\n\n\n\n\n","category":"function"},{"location":"#MethodAnalysis.direct_backedges","page":"Home","title":"MethodAnalysis.direct_backedges","text":"direct_backedges(f::Function; skip=true)\n\nCollect all backedges for a function f as pairs instance=>caller or sig=>caller pairs. The latter occur for MethodTable backedges. If skip is true, any caller listed in a MethodTable backedge is omitted from the instance backedges. \n\n\n\n\n\n","category":"function"},{"location":"#MethodAnalysis.terminal_backedges","page":"Home","title":"MethodAnalysis.terminal_backedges","text":"terminal_backedges(mi::MethodInstance)\n\nObtain the \"ultimate callers\" of mi, i.e., the reason(s) mi was compiled.\n\n\n\n\n\n","category":"function"},{"location":"#MethodAnalysis.with_all_backedges","page":"Home","title":"MethodAnalysis.with_all_backedges","text":"with_all_backedges(itr)\n\nReturn all MethodInstances detected when iterating through items in itr and any their backedges. The result includes both MethodTable and MethodInstance backedges.\n\n\n\n\n\n","category":"function"},{"location":"#utilities-1","page":"Home","title":"utilities","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"instance\ncall_type\nworlds","category":"page"},{"location":"#MethodAnalysis.instance","page":"Home","title":"MethodAnalysis.instance","text":"mi = instance(f, types)\n\nReturn the MethodInstance mi for function f and the given types. If no version compiled for these types exists, returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"#MethodAnalysis.call_type","page":"Home","title":"MethodAnalysis.call_type","text":"call_type(tt)\n\nSplit a signature type like Tuple{typeof(f),ArgTypes...} back out to (f, Tuple{ArgTypes...})\n\n\n\n\n\n","category":"function"},{"location":"#MethodAnalysis.worlds","page":"Home","title":"MethodAnalysis.worlds","text":"minmaxs = worlds(mi::MethodInstance)\n\nCollect the (min,max) world-age pairs for all CodeInstances associated with mi.\n\n\n\n\n\n","category":"function"}]
}
